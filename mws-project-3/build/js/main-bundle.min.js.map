{"version":3,"sources":["dbhelper.js","app.js"],"names":["offlineMessage","document","getElementById","noDataMessage","dataSavedMessage","saveErrorMessage","DBHelper","id","1","2","3","4","5","6","7","8","9","10","lastUpdated","this","getLastUpdated","textContent","style","display","localStorage","getItem","date","setItem","result","console","log","error","response","ok","Error","statusText","json","text","pathToResource","fetch","then","validateResponse","readResponseAsJSON","pathToAPI","data","headers","Headers","Content-Type","body","JSON","stringify","method","readResponseAsText","restaurant","imageType","width","fileExtension","map","google","maps","Marker","position","latlng","title","name","url","getRestaurantURL","animation","Animation","DROP","neighborhoods","cuisines","restaurants","markers","endpointRestaurants","elementMapsContainer","elementGoogleMaps","elementGoogleStaticMaps","elementNeighborhoodsSelect","elementCuisinesSelect","elementRestaurantsList","addEventListener","event","createMapsStatic","loadMainNetworkFirst","mapsStaticUrl","mapsImageWidth","mapsImageHeight","mapsScale","imageMapsStatic","Image","className","setAttribute","alt","intElemClientWidth","clientWidth","intElementClientHeight","clientHeight","src","height","appendChild","showGoogleMaps","getServerData","dataFromNetwork","updateNeighborhoodsUI","updateCuisinesUI","saveRestaurantsDataLocally","setLastUpdated","Date","catch","err","warn","getLocalRestaurantsData","offlineData","length","refreshRestaurantsNetworkFirst","allNeighborhoods","v","i","neighborhood","self","filter","indexOf","forEach","option","createElement","innerHTML","value","allCuisines","cuisine_type","cuisine","refreshRestaurantsUI","offline","neighborhoodIndex","selectedIndex","cuisineIndex","m","setMap","r","addRestaurantCardUI","addMarkersToMapUI","li","createResponsivePicture","divCardPrimary","divCardSecondary","address","divCardActions","more","href","picture","sizes","srcsetWebP","getImageUrlForRestaurant","srcsetJPEG","sourceWebP","srcset","type","sourceDefault","defaultImg","imageSrc","altText","getAlternativeText","window","initMap","Map","center","lat","lng","zoom","addListener","querySelector","arguments","undefined","marker","addMarkerForRestaurant","location","push"],"mappings":"6XAAA,IAAMA,eAAiBC,SAASC,eAAe,WACzCC,cAAgBF,SAASC,eAAe,WACxCE,iBAAmBH,SAASC,eAAe,cAC3CG,iBAAmBJ,SAASC,eAAe,cAW3CI,8HAKsBC,GAaxB,MAZiB,CACfC,EAAG,mCACHC,EAAG,yBACHC,EAAG,qCACHC,EAAG,+CACHC,EAAG,kCACHC,EAAG,kCACHC,EAAG,qCACHC,EAAG,4BACHC,EAAG,4BACHC,GAAI,4BAEUV,4CAMhB,IAAMW,EAAcC,KAAKC,iBACrBF,IACHlB,eAAeqB,aAAe,8BAAgCH,GAE/DlB,eAAesB,MAAMC,QAAU,gDAO/BpB,cAAcmB,MAAMC,QAAU,mDAM9B,IAAML,EAAcC,KAAKC,iBACrBF,IAAcd,iBAAiBiB,aAAe,OAASH,GAC3Dd,iBAAiBkB,MAAMC,QAAU,mDAMjClB,iBAAiBiB,MAAMC,QAAU,iDAKjC,OAAOC,aAAaC,QAAQ,sDAIRC,GACpBF,aAAaG,QAAQ,cAAeD,qCAOrBE,GACfC,QAAQC,IAAIF,oCAQEG,GACdF,QAAQC,IAAI,6CAA8CC,4CAcpCC,GACtB,IAAKA,EAASC,GACZ,MAAMC,MAAMF,EAASG,YAEvB,OAAOH,6CAQiBA,GACxB,OAAOA,EAASI,kDAOQJ,GACxB,OAAOA,EAASK,6CAeGC,GAInB,OAAOC,MAAMD,GACVE,KAAKrB,KAAKsB,kBACVD,KAAKrB,KAAKuB,wDASIC,EAAWC,GAC5B,IAAMC,EAAU,IAAIC,QAAQ,CAACC,eAAgB,qBACvCC,EAAOC,KAAKC,UAAUN,GAC5B,OAAOL,MAAMI,EAAW,CACtBQ,OAAQ,OACRN,QAASA,EACTG,KAAMA,IAEPR,KAAKrB,KAAKsB,kBACVD,KAAKrB,KAAKiC,6DASWC,GAEtB,MAAA,sBAA6BA,EAAW9C,oDAUV8C,EAAYC,EAAWC,GAErD,IAAIC,EAAgB,MACpB,OAAQF,GACN,IAAK,OACH,MACF,IAAK,OACHE,EAAgB,OAChB,MACF,QACE3B,QAAQC,IAAR,gCAA4CwB,GAEhD,YAAqB,IAAVC,EACT,OAAcF,EAAW9C,GAAzB,MAAiCgD,EAAjC,IAA0CC,EAE1C,OAAcH,EAAW9C,GAAzB,UAAqCiD,iDAOXH,EAAYI,GAQxC,OAPe,IAAIC,OAAOC,KAAKC,OAAO,CACpCC,SAAUR,EAAWS,OACrBC,MAAOV,EAAWW,KAClBC,IAAK3D,EAAS4D,iBAAiBb,GAC/BI,IAAKA,EACLU,UAAWT,OAAOC,KAAKS,UAAUC,4CA/EnC,MAAA,iCC/HAZ,SAAAA,EACAa,mBAAAA,EACAC,cAAAA,EACAC,iBAAAA,EACAC,QAAU,GACRC,oBAAAA,oCAGAC,qBAAuB1E,SAASC,eAAe,kBAC/C0E,kBAAoB3E,SAASC,eAAe,eAC5C2E,wBAA0B5E,SAASC,eAAe,sBAClD4E,2BAA6B7E,SAASC,eAAe,wBACrD6E,sBAAwB9E,SAASC,eAAe,mBAChD8E,uBAAyB/E,SAASC,eAAe,oBASvDD,SAASgF,iBAAiB,mBAAoB,SAACC,GAC7CC,mBACAC,yBAOF,IAAMD,iBAAmB,WAGvB,IAAIE,EAAAA,4DAKAC,EAAiB,IACjBC,EAAkB,IAClBC,EAAY,EAKVC,EAAkB,IAAIC,MAC5BD,EAAgBlF,GAAK,aACrBkF,EAAgBE,UAAY,yBAE5BF,EAAgBG,aAAa,UAAW,oBACxCH,EAAgBI,IACZ,yEAKJ,IAAMC,EAAqBnB,qBAAqBoB,YAC5CD,GAAsB,IACxBR,EAAiBQ,GAEjBN,EAAY,EACZF,EAAiB,KAEnB,IAAMU,EAAyBrB,qBAAqBsB,aAChDD,GAA0B,IAC5BT,EAAkBS,GAElBR,EAAY,EACZD,EAAkB,KAGpBF,EACKA,EADL,8CADwBC,EAApB,IAAsCC,GAC1C,UACyFC,EADzF,0DAEAC,EAAgBS,IAAMb,EACtBI,EAAgBlC,MAAQ+B,EACxBG,EAAgBU,OAASZ,EACzBV,wBAAwBuB,YAAYX,IAGhCY,eAAiB,WACmB,SAApCzB,kBAAkBtD,MAAMC,UAC1BqD,kBAAkBtD,MAAMC,QAAU,QAClCsD,wBAAwBvD,MAAMC,QAAU,SAiBtC6D,qBAAuB,WAC3B9E,SAASgG,cAAc5B,qBACtBlC,KAAK,SAAA+D,GACJC,sBAAsBD,GACtBE,iBAAiBF,GACjBG,2BAA2BH,GAC1B/D,KAAK,WACJlC,SAASqG,eAAe,IAAIC,QAE3BC,MAAM,SAAAC,GAEPjF,QAAQkF,KAAKD,OAEdD,MAAM,SAAAC,GACPjF,QAAQC,IAAI,qEACZkF,0BACCxE,KAAK,SAAAyE,GACCA,EAAYC,SAIfV,sBAAsBS,GACtBR,iBAAiBQ,GACjBE,uCASFX,sBAAwB,SAAC5E,GAE7B,IAAIwF,EAAmBxF,EAAO6B,IAAI,SAAC4D,EAAGC,GAAJ,OAAU1F,EAAO0F,GAAGC,eAEtDC,KAAKlD,cAAgB8C,EAAiBK,OAAO,SAACJ,EAAGC,GAAJ,OAAUF,EAAiBM,QAAQL,IAAMC,IAEtFhD,cAAcqD,QAAQ,SAAAJ,GACpB,IAAMK,EAAS3H,SAAS4H,cAAc,UACtCD,EAAOE,UAAYP,EACnBK,EAAOG,MAAQR,EACfzC,2BAA2BsB,YAAYwB,MAOrCnB,iBAAmB,SAAC7E,GAExB,IAAIoG,EAAcpG,EAAO6B,IAAI,SAAC4D,EAAGC,GAAJ,OAAU1F,EAAO0F,GAAGW,eAEjDT,KAAKjD,SAAWyD,EAAYP,OAAO,SAACJ,EAAGC,GAAJ,OAAUU,EAAYN,QAAQL,IAAMC,IAEvE/C,SAASoD,QAAQ,SAAAO,GACf,IAAMN,EAAS3H,SAAS4H,cAAc,UACtCD,EAAOE,UAAYI,EACnBN,EAAOG,MAAQG,EACfnD,sBAAsBqB,YAAYwB,MAOhCT,+BAAiC,WACrC7G,SAASgG,cAAc5B,qBACtBlC,KAAK,SAAA+D,GACJ4B,sBAAqB,EAAO5B,GAC5BG,2BAA2BH,GAC1B/D,KAAK,WACJlC,SAASqG,eAAe,IAAIC,QAE3BC,MAAM,SAAAC,GAEPjF,QAAQkF,KAAKD,OAEdD,MAAM,SAAAC,GACPjF,QAAQC,IAAI,qEACZkF,0BACCxE,KAAK,SAAAyE,GACCA,EAAYC,QAIfiB,sBAAqB,EAAMlB,QAS7BkB,qBAAuB,SAACC,EAASxG,GAErC,IAAMyG,EAAoBvD,2BAA2BwD,cAC/CC,EAAexD,sBAAsBuD,cACrCf,EAAezC,2BAA2BuD,GAAmBN,MAC7DG,EAAUnD,sBAAsBwD,GAAcR,MAGpDP,KAAKhD,YAAc,GACnBQ,uBAAuB8C,UAAY,GACnCrD,QAAQkD,QAAQ,SAAAa,GAAA,OAAKA,EAAEC,OAAO,QAC9BhE,QAAU,GAGV+C,KAAKhD,YAAc5C,EACC,OAAhB2F,IACFC,KAAKhD,YAAcgD,KAAKhD,YAAYiD,OAAO,SAAAiB,GAAA,OAAKA,EAAEnB,cAAgBA,KAErD,OAAXW,IACFV,KAAKhD,YAAcgD,KAAKhD,YAAYiD,OAAO,SAAAiB,GAAA,OAAKA,EAAET,cAAgBC,KAIpEV,KAAKhD,YAAYmD,QAAQ,SAAAtE,GACvB2B,uBAAuBoB,YAAYuC,oBAAoBtF,MAEpD+E,GACHQ,qBAOED,oBAAsB,SAACtF,GAC3B,IAAMwF,EAAK5I,SAAS4H,cAAc,MAClCgB,EAAGlD,UAAY,kBAEfkD,EAAGzC,YAAY0C,wBAAwBzF,IAGvC,IAAM0F,EAAiB9I,SAAS4H,cAAc,OAC9CkB,EAAepD,UAAY,eAC3B,IAAM3B,EAAO/D,SAAS4H,cAAc,MACpC7D,EAAK2B,UAAY,aACjB3B,EAAK8D,UAAYzE,EAAWW,KAC5B+E,EAAe3C,YAAYpC,GAC3B,IAAMuD,EAAetH,SAAS4H,cAAc,MAC5CN,EAAa5B,UAAY,gBACzB4B,EAAaO,UAAYzE,EAAWkE,aACpCwB,EAAe3C,YAAYmB,GAC3BsB,EAAGzC,YAAY2C,GAGf,IAAMC,EAAmB/I,SAAS4H,cAAc,OAChDmB,EAAiBrD,UAAY,iBAG7B,IAAMsD,EAAUhJ,SAAS4H,cAAc,WACvCoB,EAAQtD,UAAY,yBACpBsD,EAAQnB,UAAYzE,EAAW4F,QAC/BD,EAAiB5C,YAAY6C,GAC7BJ,EAAGzC,YAAY4C,GAGf,IAAME,EAAiBjJ,SAAS4H,cAAc,OAC9CqB,EAAevD,UAAY,eAC3B,IAAMwD,EAAOlJ,SAAS4H,cAAc,KAOpC,OANAsB,EAAKxD,UAAY,oBACjBwD,EAAKrB,UAAY,eACjBqB,EAAKC,KAAO9I,SAAS4D,iBAAiBb,GACtC6F,EAAe9C,YAAY+C,GAC3BN,EAAGzC,YAAY8C,GAERL,GAuEHC,wBAA0B,SAACzF,GAC/B,IAAMgG,EAAUpJ,SAAS4H,cAAc,WAGjCyB,EAAQ,uFAGRC,EACDjJ,SAASkJ,yBAAyBnG,EAAY,OAAQ,KADrD,eAEF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAFpD,eAGF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAHpD,eAIF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAJpD,eAKF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KALpD,eAMF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KANpD,QAQAoG,EACDnJ,SAASkJ,yBAAyBnG,EAAY,OAAQ,KADrD,eAEF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAFpD,eAGF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAHpD,eAIF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KAJpD,eAKF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KALpD,eAMF/C,SAASkJ,yBAAyBnG,EAAY,OAAQ,KANpD,QAQAqG,EAAazJ,SAAS4H,cAAc,UAC1C6B,EAAWC,OAASJ,EACpBG,EAAWJ,MAAQA,EACnBI,EAAWE,KAAO,aAClBP,EAAQjD,YAAYsD,GAEpB,IAAMG,EAAgB5J,SAAS4H,cAAc,UAC7CgC,EAAcF,OAASF,EACvBI,EAAcP,MAAQA,EACtBO,EAAcD,KAAO,aACrBP,EAAQjD,YAAYyD,GAEpB,IAAMC,EAAa7J,SAAS4H,cAAc,OAEpCkC,EAAWzJ,SAASkJ,yBAAyBnG,EAAY,OAAQ,KACvEyG,EAAW5D,IAAM6D,EAEjB,IAAIC,EAAU1J,SAAS2J,mBAAmB5G,EAAW9C,IAOrD,OANKyJ,IACHA,EAAAA,cAAwB3G,EAAWW,MAErC8F,EAAWjE,IAAMmE,EACjBX,EAAQjD,YAAY0D,GAEbT,GAQTa,OAAOC,QAAU,YAIf1G,IAAM,IAAIC,OAAOC,KAAKyG,IAAIxF,kBAAmB,CAC3CyF,OAJQ,CAACC,IAAK,UAAWC,KAAM,WAK/BC,KAAM,MASJC,YAAY,cAJD,WACYxK,SAASyK,cAAc,uBAC/B9E,aAAa,QAAS,yCAIzCuB,kCAMF,IAAMyB,kBAAoB,YAAoC,EAAA+B,UAAAzD,aAAA0D,IAAAD,UAAA,GAAAA,UAAA,GAArBnD,KAAKhD,aAChCmD,QAAQ,SAAAtE,GAClB,IAAMwH,EAASvK,SAASwK,uBAAuBzH,EAAYmE,KAAK/D,KAChEC,OAAOC,KAAKuB,MAAMuF,YAAYI,EAAQ,QAAS,WAC7CX,OAAOa,SAAS3B,KAAOyB,EAAO5G,MAEhCQ,QAAQuG,KAAKH","file":"main-bundle.min.js","sourcesContent":["const offlineMessage = document.getElementById('offline');\r\nconst noDataMessage = document.getElementById('no-data');\r\nconst dataSavedMessage = document.getElementById('data-saved');\r\nconst saveErrorMessage = document.getElementById('save-error');\r\n\r\n\r\n/**\r\n * DBHelper provides functions to interact with the local development API server\r\n * provided by Udacity for project 2.\r\n * https://github.com/udacity/mws-restaurant-stage-2\r\n * curl \"http://localhost:1337/restaurants\"\r\n * curl \"http://localhost:1337/restaurants/{3}\"\r\n */\r\n\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Alternative Text as the API server doesn't provide it.\r\n   */\r\n  static getAlternativeText(id) {\r\n    const altTexts = {\r\n      1: \"Interior of Mission Chinese Food\",\r\n      2: \"Pizza Quattro Formaggi\",\r\n      3: \"Interior of Kang Ho Dong Baekjeong\",\r\n      4: \"Outside view of Katz's Delicatessen at night\",\r\n      5: \"Open kitchen of Roberta's Pizza\",\r\n      6: \"People queueing at Hometown BBQ\",\r\n      7: \"Outside view of Superiority Burger\",\r\n      8: \"Outside view of The Dutch\",\r\n      9: \"People eating at Mu Ramen\",\r\n      10: \"Interior of Casa Enrique\"\r\n    };\r\n    return altTexts[id];\r\n  }\r\n\r\n  // Alert user that data may not be current\r\n  // \"You're offline and viewing stored data.\"\r\n  static messageOffline() {\r\n    const lastUpdated = this.getLastUpdated();\r\n    if (lastUpdated) {\r\n     offlineMessage.textContent += ' Last fetched server data: ' + lastUpdated;\r\n    }\r\n    offlineMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that there is no data available.\r\n  // \"You're offline and local data is unavailable.\"\r\n  static messageNoData() {\r\n    //\r\n    noDataMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that data has been saved for offline.\r\n  // \"Server data was saved for offline mode.\"\"\r\n  static messageDataSaved() {\r\n    const lastUpdated = this.getLastUpdated();\r\n    if (lastUpdated) {dataSavedMessage.textContent += ' on ' + lastUpdated;}\r\n    dataSavedMessage.style.display = 'block';\r\n  }\r\n\r\n  // Alert user that data couldn't be saved offline\r\n  // \"Server data couldn't be saved offline.\"\"\r\n  static messageSaveError() {\r\n    saveErrorMessage.style.display = 'block';\r\n  }\r\n\r\n  // Util network function.\r\n  static getLastUpdated() {\r\n    return localStorage.getItem('lastUpdated');\r\n  }\r\n\r\n  // Util network function.\r\n  static setLastUpdated(date) {\r\n    localStorage.setItem('lastUpdated', date);\r\n  }\r\n\r\n  /*\r\n   * logResult is available for debugging puprposes, it does some logging\r\n   * of the JSON data.\r\n   */\r\n  static logResult(result) {\r\n    console.log(result);\r\n  }\r\n\r\n  /*\r\n   * The fetch call returns a promise that resolves to a response object.\r\n   * If the request does not complete, .catch takes over and is passed the\r\n   * corresponding error.\r\n   */\r\n  static logError(error) {\r\n    console.log('[ERROR] Looks like there was a problem: \\n', error);\r\n  }\r\n\r\n  /*\r\n   * validateResponse checks if the response is valid (is it a 200-299?).\r\n   * If it isn't, an error is thrown, skipping the rest of the then blocks and\r\n   * triggering the catch block. Without this check bad responses are passed\r\n   * down the chain and could break later code that may rely on receiving\r\n   * a valid response. If the response is valid, it is passed to\r\n   * readResponseAsJSON.\r\n   * TODO: respond with custom pages for different errors or handle other\r\n   * responses that are not ok (i.e., not 200-299), but still usable\r\n   * (e.g., status codes in the 300 range)\r\n   */\r\n  static validateResponse(response) {\r\n    if (!response.ok) {\r\n      throw Error(response.statusText);\r\n    }\r\n    return response;\r\n  }\r\n\r\n  /*\r\n   * readResponseAsJSON reads the body of the response using the Response.json()\r\n   * method. This method returns a promise that resolves to JSON. Once this\r\n   * promise resolves, the JSON data is passed to logResult.\r\n   */\r\n  static readResponseAsJSON(response) {\r\n    return response.json();\r\n  }\r\n\r\n  /*\r\n   * readResponseAsText reads the body of the response using the Response.text()\r\n   * method.\r\n   */\r\n  static readResponseAsText(response) {\r\n    return response.text();\r\n  }\r\n\r\n  /**\r\n   * Get the database URL.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337;\r\n    return `http://localhost:${port}`;\r\n  }\r\n\r\n  /**\r\n   * getServerData\r\n   */\r\n  static getServerData(pathToResource) {\r\n    // Fetch is called on a resource and Fetch returns a promise that will\r\n    // resolve to a response object. When the promise resolves, the response\r\n    // object is passed to validateResponse.\r\n    return fetch(pathToResource)\r\n      .then(this.validateResponse)\r\n      .then(this.readResponseAsJSON)\r\n      // Once the promise resolves, the JSON data is passed to logResult.\r\n      // .then(this.logResult)\r\n      // .catch(this.logError);\r\n  }\r\n\r\n  /**\r\n   * postRequest\r\n   */\r\n  static postRequest(pathToAPI, data) {\r\n    const headers = new Headers({'Content-Type': 'application/json'});\r\n    const body = JSON.stringify(data);\r\n    return fetch(pathToAPI, {\r\n      method: 'POST',\r\n      headers: headers,\r\n      body: body\r\n    })\r\n    .then(this.validateResponse)\r\n    .then(this.readResponseAsText)\r\n    // Once the promise resolves, the text data is passed to logResult.\r\n    // .then(this.logResult)\r\n    // .catch(this.logError);\r\n  }\r\n\r\n  /**\r\n   * Returns the relative url for a restaurant.\r\n   */\r\n  static getRestaurantURL(restaurant) {\r\n    // return `./restaurant.html?id=${restaurant.id}`\r\n    return `restaurant.html?id=${restaurant.id}`\r\n  }\r\n\r\n  /**\r\n   * Returns the restaurant image URL.\r\n   * Using id to construct urls as the local development API server doesn't\r\n   * always have a photograph field.\r\n   * jpg is default image type.\r\n   * 800 is default width.\r\n   */\r\n  static getImageUrlForRestaurant(restaurant, imageType, width) {\r\n    // Default image type is jpeg.\r\n    let fileExtension = 'jpg';\r\n    switch (imageType) {\r\n      case 'jpeg':\r\n        break;\r\n      case 'webp':\r\n        fileExtension = 'webp';\r\n        break;\r\n      default:\r\n        console.log(`[DEBUG] unhandled imageType: ${imageType}`);\r\n    }\r\n    if (typeof width !== 'undefined') {\r\n      return `img/${restaurant.id}_w_${width}.${fileExtension}`;\r\n    } else {\r\n      return `img/${restaurant.id}_w_800.${fileExtension}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a Google Maps marker for a restaurant.\r\n   */\r\n  static addMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.getRestaurantURL(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n}\r\n","/**\r\n * TODO: Add to Home Screen (aka Web App Install Banners)\r\n * trigger the Add to Home Screen prompt by using the beforeinstallprompt event.\r\n * https://developers.google.com/web/fundamentals/app-install-banners/\r\n */\r\n\r\n// Declare global variables.\r\nlet map;\r\nlet neighborhoods;\r\nlet cuisines;\r\nlet restaurants;\r\nlet markers = [];\r\nconst endpointRestaurants = `http://localhost:1337/restaurants`;\r\n\r\n// Declare the id elements.\r\nconst elementMapsContainer = document.getElementById('maps-container');\r\nconst elementGoogleMaps = document.getElementById('google-maps');\r\nconst elementGoogleStaticMaps = document.getElementById('google-static-maps');\r\nconst elementNeighborhoodsSelect = document.getElementById('neighborhoods-select');\r\nconst elementCuisinesSelect = document.getElementById('cuisines-select');\r\nconst elementRestaurantsList = document.getElementById('restaurants-list');\r\n\r\n/**\r\n * Start the following when the initial HTML document has been\r\n * completely loaded and parsed, without waiting for stylesheets, images,\r\n * and subframes to finish loading.\r\n * Fetch neighborhoods and cuisines.\r\n * https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n  createMapsStatic();\r\n  loadMainNetworkFirst();\r\n});\r\n\r\n/**\r\n * Embed a Google Maps image on your web page using the Maps Static API.\r\n * https://developers.google.com/maps/documentation/maps-static/intro\r\n */\r\nconst createMapsStatic = () => {\r\n  // Create the Maps Static API Url\r\n  // https://developers.google.com/maps/documentation/maps-static/dev-guide\r\n  let mapsStaticUrl \r\n    = `https://maps.googleapis.com/maps/api/staticmap?parameters`;\r\n  const mapsCenter = `40.722216,-73.987501`;\r\n  const mapsZoom = 12;\r\n  // const mapsImageSizes = '640x640';\r\n  let mapsImageWidth = 640;\r\n  let mapsImageHeight = 640;\r\n  let mapsScale = 1;\r\n  const mapsImageFormat = 'jpg';\r\n  // TODO: move the API Key to either environmental variables or config.js\r\n  const mapsApiKey = `AIzaSyDm9CBeGB2XpSOVQXsuyo-kJtdHSNGiF4k`;\r\n  // const imageMapsStatic = document.createElement('img');\r\n  const imageMapsStatic = new Image();\r\n  imageMapsStatic.id = 'static-map';\r\n  imageMapsStatic.className = 'google-maps-static-img';\r\n  // Adding an event needs to be a function.\r\n  imageMapsStatic.setAttribute('onclick', 'showGoogleMaps()');\r\n  imageMapsStatic.alt \r\n    = 'Static map showing high level view of New York, Manhattan and Brooklyn';\r\n  // Determine image sizes, free plan allows max 640x640 on scale 1 and\r\n  // 640x640 on scale 2 returns 1280x1280 pixels.\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\r\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight\r\n  const intElemClientWidth = elementMapsContainer.clientWidth;\r\n  if (intElemClientWidth <= 640) {\r\n    mapsImageWidth = intElemClientWidth;\r\n  } else {\r\n    mapsScale = 2;\r\n    mapsImageWidth = 640\r\n  }\r\n  const intElementClientHeight = elementMapsContainer.clientHeight;\r\n  if (intElementClientHeight <= 640) {\r\n    mapsImageHeight = intElementClientHeight;\r\n  } else {\r\n    mapsScale = 2;\r\n    mapsImageHeight = 640\r\n  }\r\n  let mapsImageSizes = `${mapsImageWidth}x${mapsImageHeight}`;\r\n  mapsStaticUrl = \r\n    `${mapsStaticUrl}&center=${mapsCenter}&zoom=${mapsZoom}&size=${mapsImageSizes}&scale=${mapsScale}&format=${mapsImageFormat}&key=${mapsApiKey}`;\r\n  imageMapsStatic.src = mapsStaticUrl;\r\n  imageMapsStatic.width = mapsImageWidth;\r\n  imageMapsStatic.height = mapsImageHeight;\r\n  elementGoogleStaticMaps.appendChild(imageMapsStatic);\r\n}\r\n\r\nconst showGoogleMaps = () => {\r\n  if (elementGoogleMaps.style.display === 'none') {\r\n    elementGoogleMaps.style.display = 'block';\r\n    elementGoogleStaticMaps.style.display = 'none';\r\n  }\r\n}\r\n\r\n/**\r\n * Fetch all neighborhoods and cuisines from network and fallback to IndexedDB,\r\n * update UI.\r\n * In loadMainNetworkFirst, once the server data is received, IndexedDB and\r\n * the page are updated. Then, when the data is successfully saved, a timestamp\r\n * is stored and the user is notified that the data is available for\r\n * offline use. If there is no network availability when this function is\r\n * called, then the getServerData function rejects and the catch method takes\r\n * over. In the catch call, the getLocalRestaurantsData function retrieves\r\n * local data from IndexedDB. If there isn't any local data saved, then\r\n * the user is alerted by messageNoData. Otherwise the local data is displayed\r\n * and a message informs the user that the data might be outdated.\r\n */\r\nconst loadMainNetworkFirst = () => {\r\n  DBHelper.getServerData(endpointRestaurants)\r\n  .then(dataFromNetwork => {\r\n    updateNeighborhoodsUI(dataFromNetwork);\r\n    updateCuisinesUI(dataFromNetwork);\r\n    saveRestaurantsDataLocally(dataFromNetwork)\r\n    .then(() => {\r\n      DBHelper.setLastUpdated(new Date());\r\n      // DBHelper.messageDataSaved();\r\n    }).catch(err => {\r\n      // DBHelper.messageSaveError();\r\n      console.warn(err);\r\n    });\r\n  }).catch(err => {\r\n    console.log('[DEBUG] Network requests have failed, this is expected if offline');\r\n    getLocalRestaurantsData()\r\n    .then(offlineData => {\r\n      if (!offlineData.length) {\r\n        // DBHelper.messageNoData();\r\n      } else {\r\n        // DBHelper.messageOffline();\r\n        updateNeighborhoodsUI(offlineData);\r\n        updateCuisinesUI(offlineData);\r\n        refreshRestaurantsNetworkFirst();\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Update UI of Neighborhoods select element.\r\n */\r\nconst updateNeighborhoodsUI = (result) => {\r\n  // Get all neighborhoods from all restaurants.\r\n  let allNeighborhoods = result.map((v, i) => result[i].neighborhood);\r\n  // Remove duplicates from neighborhoods and assign to global variable.\r\n  self.neighborhoods = allNeighborhoods.filter((v, i) => allNeighborhoods.indexOf(v) == i);\r\n  // Update the neighborhoods select.\r\n  neighborhoods.forEach(neighborhood => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = neighborhood;\r\n    option.value = neighborhood;\r\n    elementNeighborhoodsSelect.appendChild(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Update UI of Cuisines select element.\r\n */\r\nconst updateCuisinesUI = (result) => {\r\n  // Get all cuisines from all restaurants.\r\n  let allCuisines = result.map((v, i) => result[i].cuisine_type);\r\n  // Remove duplicates from cuisines and assign to global variable.\r\n  self.cuisines = allCuisines.filter((v, i) => allCuisines.indexOf(v) == i);\r\n  // Update the cuisines select.\r\n  cuisines.forEach(cuisine => {\r\n    const option = document.createElement('option');\r\n    option.innerHTML = cuisine;\r\n    option.value = cuisine;\r\n    elementCuisinesSelect.appendChild(option);\r\n  });\r\n}\r\n\r\n/**\r\n * Fetch all restaurants from network and fallback to IndexedDB, update UI.\r\n */\r\nconst refreshRestaurantsNetworkFirst = () => {\r\n  DBHelper.getServerData(endpointRestaurants)\r\n  .then(dataFromNetwork => {\r\n    refreshRestaurantsUI(false, dataFromNetwork);\r\n    saveRestaurantsDataLocally(dataFromNetwork)\r\n    .then(() => {\r\n      DBHelper.setLastUpdated(new Date());\r\n      // DBHelper.messageDataSaved();\r\n    }).catch(err => {\r\n      // DBHelper.messageSaveError();\r\n      console.warn(err);\r\n    });\r\n  }).catch(err => {\r\n    console.log('[DEBUG] Network requests have failed, this is expected if offline');\r\n    getLocalRestaurantsData()\r\n    .then(offlineData => {\r\n      if (!offlineData.length) {\r\n        // DBHelper.messageNoData();\r\n      } else {\r\n        // DBHelper.messageOffline();\r\n        refreshRestaurantsUI(true, offlineData);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Update ul restaurants-list and markers on map for current restaurants.\r\n */\r\nconst refreshRestaurantsUI = (offline, result) => {\r\n  // Retrieve the selected neighborhood and cuisine.\r\n  const neighborhoodIndex = elementNeighborhoodsSelect.selectedIndex;\r\n  const cuisineIndex = elementCuisinesSelect.selectedIndex;\r\n  const neighborhood = elementNeighborhoodsSelect[neighborhoodIndex].value;\r\n  const cuisine = elementCuisinesSelect[cuisineIndex].value;\r\n\r\n  // Clear ul restaurants-list and markers on map for current restaurants.\r\n  self.restaurants = [];\r\n  elementRestaurantsList.innerHTML = '';\r\n  markers.forEach(m => m.setMap(null));\r\n  markers = [];\r\n\r\n  // Filter the data by neighborhood and cuisine.\r\n  self.restaurants = result;\r\n  if (neighborhood != 'all') {\r\n    self.restaurants = self.restaurants.filter(r => r.neighborhood == neighborhood);\r\n  }\r\n  if (cuisine != 'all') {\r\n    self.restaurants = self.restaurants.filter(r => r.cuisine_type == cuisine);\r\n  }\r\n\r\n  // Create ul restaurants-list and add markers on map for current restaurants.\r\n  self.restaurants.forEach(restaurant => {\r\n    elementRestaurantsList.appendChild(addRestaurantCardUI(restaurant));\r\n  });\r\n  if (!offline) {\r\n    addMarkersToMapUI();\r\n  }\r\n}\r\n\r\n/**\r\n * Create a restaurant card in a li element.\r\n */\r\nconst addRestaurantCardUI = (restaurant) => {\r\n  const li = document.createElement('li');\r\n  li.className = 'restaurant-card';\r\n\r\n  li.appendChild(createResponsivePicture(restaurant));\r\n\r\n  // Create a div with class card-primary that contains h2, h3.\r\n  const divCardPrimary = document.createElement('div');\r\n  divCardPrimary.className = 'card-primary';\r\n  const name = document.createElement('h2');\r\n  name.className = 'card-title';\r\n  name.innerHTML = restaurant.name;\r\n  divCardPrimary.appendChild(name);\r\n  const neighborhood = document.createElement('h3');\r\n  neighborhood.className = 'card-subtitle';\r\n  neighborhood.innerHTML = restaurant.neighborhood;\r\n  divCardPrimary.appendChild(neighborhood);\r\n  li.appendChild(divCardPrimary);\r\n\r\n  // Create a div with class card-secondary that contains further content.\r\n  const divCardSecondary = document.createElement('div');\r\n  divCardSecondary.className = 'card-secondary';\r\n  // Use contact address element.\r\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address\r\n  const address = document.createElement('address');\r\n  address.className = 'card-secondary-content';\r\n  address.innerHTML = restaurant.address;\r\n  divCardSecondary.appendChild(address);\r\n  li.appendChild(divCardSecondary);\r\n\r\n  // Create a div with class card-actions.\r\n  const divCardActions = document.createElement('div');\r\n  divCardActions.className = 'card-actions';\r\n  const more = document.createElement('a');\r\n  more.className = 'card-actions-link';\r\n  more.innerHTML = 'View Details';\r\n  more.href = DBHelper.getRestaurantURL(restaurant);\r\n  divCardActions.appendChild(more);\r\n  li.appendChild(divCardActions);\r\n\r\n  return li;\r\n}\r\n\r\n/**\r\n * Create a responsive image.\r\n *\r\n * Main page\r\n * 0 to 479px: card has width 100%, so 1 img 100% (455 x 321).\r\n * 480 to 599px: card has width 100%, so 1 img fullwidth (567 x 425).\r\n * 600 to 839px: card has width 45%, so 2 img 45% (378 x 283).\r\n * 840 to 959px: card has width 45%, so 2 img 45% (432 x 324).\r\n * 960 to 1279px: card has width 30%, so 3 img 30% (384 x 289).\r\n * 1280px to x: card has width 22.5%, so 4 img 22.5% (minimum 288 x 216).\r\n *\r\n * Restaurant Info\r\n * 0 to 479px: card has width 100%, so 1 img 100% (479 x 359).\r\n * 480 to 599px: card has width 100%, so 1 img fullwidth (599 x 449).\r\n * 600 to 839px: card has width 50%, so 1 img 50% (419.5 x 315).\r\n * 840 to 959px: card has width 50%, so 1 img 50% (479.5 x 360).\r\n * 960 to 1279px: card has width 50%, so 1 img 50% (639.5 x 480).\r\n * 1280px to x: card has width 50%, so 1 img 50% (minimum 640 x 480).\r\n *\r\n * Image breakpoints have been determined using the Cloudinary generator.\r\n * http://www.responsivebreakpoints.com/\r\n * Image widths are 300, 433, 552, 653, 752, 800\r\n *\r\n * The srcset attribute gives the browser the option to choose which file\r\n * to use. However, the browser has no way of determining the file sizes before\r\n * it loads them, so it always chooses the first image in the list.\r\n *\r\n * To load the correct image size based on the viewport width we need to tell\r\n * the browser how big each file is before it fetches them.\r\n * By adding a width descriptor to each file in the srcset, we are telling\r\n * the browser the width of each image in pixels before it fetches the image.\r\n * The browser can then use these widths to decide which image to fetch based\r\n * on its window size. It fetches the image with the smallest width that is\r\n * still larger than the viewport width.\r\n *\r\n * Because the CSS is parsed after the HTML at runtime, the browser has no way\r\n * to know what the final display size of the image will be when it fetches it.\r\n * Unless we tell it otherwise, the browser assumes the images will be displayed\r\n * at 100% of the viewport width and fetches the images based on this.\r\n *\r\n * The sizes value matches the image's max-width value in the CSS. The browser\r\n * now has everything it needs to choose the correct image version. The browser\r\n * knows its own viewport width and the pixel density of the user's device,\r\n * and we have given it the source files' dimensions (using width descriptor)\r\n * and the image sizes relative to the viewport (the sizes attribute).\r\n *\r\n * The media query tests the viewport width of the screen, and applies the CSS.\r\n * We can tell the browser about the media query in the sizes attribute so that\r\n * it fetches the correct image when the image changes size.\r\n *\r\n * We can use the <picture> element and the <source> element, in combination\r\n * with media queries, to change the image source as the window is resized.\r\n *\r\n * The <picture> element lets us define multiple source files using the\r\n * <source> tag. This is different than simply using an <img> tag with the\r\n * srcset attribute because the source tag lets us add things like media queries\r\n * to each set of sources. Instead of giving the browser the image sizes and\r\n * letting it decide which files to use, we can define the images to use at\r\n * each window size.\r\n *\r\n * If the user's browser doesn't support the <picture> element, it fetches\r\n * whatever is in the <img> element. The <picture> element is just used to\r\n * specify multiple sources for the <img> element contained in it. The <img>\r\n * element is what displays the image.\r\n *\r\n * Display density descriptors are great for fixed width images, but are\r\n * insufficient for flexible images.\r\n */\r\nconst createResponsivePicture = (restaurant) => {\r\n  const picture = document.createElement('picture');\r\n\r\n  // sizes: the browser ignores everything after the first matching condition.\r\n  const sizes = '(min-width: 80rem) 22.5vw, (min-width: 60rem) 30vw, (min-width: 37.5rem) 45vw, 100vw';\r\n\r\n  // srcset\r\n  const srcsetWebP =\r\n    `${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 300)} 300w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 433)} 433w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 552)} 552w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 653)} 653w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 752)} 752w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'webp', 800)} 800w`;\r\n\r\n  const srcsetJPEG =\r\n    `${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 300)} 300w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 433)} 433w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 552)} 552w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 653)} 653w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 752)} 752w,\r\n    ${DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 800)} 800w`;\r\n\r\n  const sourceWebP = document.createElement('source');\r\n  sourceWebP.srcset = srcsetWebP;\r\n  sourceWebP.sizes = sizes;\r\n  sourceWebP.type = 'image/webp';\r\n  picture.appendChild(sourceWebP);\r\n\r\n  const sourceDefault = document.createElement('source');\r\n  sourceDefault.srcset = srcsetJPEG;\r\n  sourceDefault.sizes = sizes;\r\n  sourceDefault.type = 'image/jpeg';\r\n  picture.appendChild(sourceDefault);\r\n\r\n  const defaultImg = document.createElement('img');\r\n  // Get default image which should be width 800.\r\n  const imageSrc = DBHelper.getImageUrlForRestaurant(restaurant, 'jpeg', 800);\r\n  defaultImg.src = imageSrc;\r\n\r\n  let altText = DBHelper.getAlternativeText(restaurant.id);\r\n  if (!altText) {\r\n    altText = `Restaurant ${restaurant.name}`;\r\n  }\r\n  defaultImg.alt = altText;\r\n  picture.appendChild(defaultImg);\r\n\r\n  return picture;\r\n}\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n * https://developers.google.com/maps/documentation/javascript/tutorial\r\n * https://developers.google.com/maps/documentation/javascript/tutorial#Loading_the_Maps_API\r\n */\r\nwindow.initMap = () => {\r\n  let loc = {lat: 40.722216, lng: -73.987501};\r\n  // Not using scrollwheel: False anymore, using default gestureHandling: auto\r\n  // https://developers.google.com/maps/documentation/javascript/interaction\r\n  map = new google.maps.Map(elementGoogleMaps, {\r\n    center: loc,\r\n    zoom: 12\r\n  });\r\n  // a11y - Frames must have non-empty title attribute\r\n  // https://dequeuniversity.com/rules/axe/2.2/frame-title\r\n  // https://developers.google.com/maps/documentation/javascript/events\r\n  let setTitle = () => {\r\n    const iFrameGoogleMaps = document.querySelector('#google-maps iframe');\r\n    iFrameGoogleMaps.setAttribute('title', 'Google Maps overview of restaurants');\r\n  }\r\n  map.addListener('tilesloaded', setTitle);\r\n  // Refresh all restaurants.\r\n  refreshRestaurantsNetworkFirst();\r\n}\r\n\r\n/**\r\n * Add markers for current restaurants to the map.\r\n */\r\nconst addMarkersToMapUI = (restaurants = self.restaurants) => {\r\n  restaurants.forEach(restaurant => {\r\n    const marker = DBHelper.addMarkerForRestaurant(restaurant, self.map);\r\n    google.maps.event.addListener(marker, 'click', () => {\r\n      window.location.href = marker.url\r\n    });\r\n    markers.push(marker);\r\n  });\r\n}\r\n"],"sourceRoot":"/source/"}